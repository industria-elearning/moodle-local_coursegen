{"version":3,"file":"course_streaming.min.js","sources":["../src/course_streaming.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Course Streaming Module for handling real-time course generation\n *\n * @module     local_datacurso/course_streaming\n * @copyright  2025 Wilber Narvaez <soluciones@buendata.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport { createCourse } from \"local_datacurso/repository/chatbot\";\nimport { get_string } from \"core/str\";\n\n// Global state for scroll behavior\nlet userHasScrolled = false;\nlet scrollTimeout = null;\n\n/**\n * Check if user is at the bottom of the scrollable container\n * @param {Element} element - The scrollable element\n * @returns {boolean} - True if user is at bottom\n */\nconst isAtBottom = (element) => {\n  const threshold = 50; // 50px threshold\n  return (\n    element.scrollTop + element.clientHeight >= element.scrollHeight - threshold\n  );\n};\n\n/**\n * Setup scroll detection to pause auto-scroll when user scrolls manually\n * @param {Element} scrollContainer - The container to monitor for scroll\n */\nconst setupScrollDetection = (scrollContainer) => {\n  if (!scrollContainer) {\n    return;\n  }\n\n  const handleScroll = () => {\n    // Clear existing timeout\n    if (scrollTimeout) {\n      clearTimeout(scrollTimeout);\n    }\n\n    // Mark that user has scrolled\n    userHasScrolled = true;\n\n    // Check if user scrolled back to bottom\n    if (isAtBottom(scrollContainer)) {\n      // Reset flag after a short delay to resume auto-scroll\n      scrollTimeout = setTimeout(() => {\n        userHasScrolled = false;\n      }, 1000);\n    }\n  };\n\n  scrollContainer.addEventListener(\"scroll\", handleScroll, { passive: true });\n};\n\n/**\n * Start course streaming from the provided URL\n * @param {string} streamingUrl - The EventSource URL for streaming\n * @param {Element} container - Container element for displaying results\n * @param {boolean} isCorrection - Whether this is a plan correction (don't clear existing content)\n * @returns {Promise} Promise that resolves when streaming is complete\n */\nexport const startStreaming = async (\n  streamingUrl,\n  container,\n  isCorrection = false\n) => {\n  const progressIndicator = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming/progress']\"\n  );\n  const eventList = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming']\"\n  );\n  const progressIcon = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming/progress/icon']\"\n  );\n\n  // Create local buffer and RAF state for this streaming instance\n  let htmlBuffer = \"\";\n  let rafPending = false;\n\n  // Only clear content if this is not a correction\n  if (!isCorrection) {\n    eventList.innerHTML = \"\";\n  }\n  if (progressIndicator) {\n    progressIndicator.style.display = \"block\";\n  }\n\n  // Reset scroll state for new streaming session\n  userHasScrolled = false;\n  if (scrollTimeout) {\n    clearTimeout(scrollTimeout);\n    scrollTimeout = null;\n  }\n\n  // Setup scroll detection on modal body\n  const modalBody = document.querySelector(\".modal-body\");\n  if (modalBody) {\n    setupScrollDetection(modalBody);\n  }\n\n  // Disable both planning buttons during streaming\n  const acceptBtn = document.getElementById(\"accept-planning-btn\");\n  const adjustBtn = document.getElementById(\"adjust-planning-btn\");\n  if (acceptBtn) {\n    acceptBtn.disabled = true;\n  }\n  if (adjustBtn) {\n    adjustBtn.disabled = true;\n  }\n\n  // Local functions for this streaming instance\n  const updateHtmlSoon = (container) => {\n    if (rafPending) {\n      return;\n    }\n    rafPending = true;\n    requestAnimationFrame(() => {\n      rafPending = false;\n      container.innerHTML = htmlBuffer;\n      // Only auto-scroll if user hasn't manually scrolled\n      if (!userHasScrolled) {\n        const modalBody = document.querySelector(\".modal-body\");\n        if (modalBody) {\n          modalBody.scrollTop = modalBody.scrollHeight;\n        } else {\n          container.scrollTop = container.scrollHeight;\n        }\n      }\n    });\n  };\n\n  const appendToken = (token, container) => {\n    htmlBuffer += token;\n    updateHtmlSoon(container);\n  };\n\n  const evtSource = new EventSource(streamingUrl);\n\n  evtSource.addEventListener(\"assistant_token\", (event) => {\n    appendToken(event.data, eventList);\n  });\n\n  evtSource.addEventListener(\"assistant_message_end\", () => {\n    progressIcon.innerHTML = `\n        <div class=\"bg-success rounded-circle d-flex align-items-center justify-content-center\"\n              style=\"width: 1.5rem; height: 1.5rem;\">\n          <i class=\"text-white\" style=\"font-size: 0.8rem;\">✓</i>\n        </div>\n      `;\n    const planningActions = document.getElementById(\"course-planning-actions\");\n    if (planningActions) {\n      planningActions.style.display = \"block\";\n    }\n\n    // Re-enable both planning buttons after streaming completes\n    const acceptBtn = document.getElementById(\"accept-planning-btn\");\n    const adjustBtn = document.getElementById(\"adjust-planning-btn\");\n    if (acceptBtn) {\n      acceptBtn.disabled = false;\n    }\n    if (adjustBtn) {\n      adjustBtn.disabled = false;\n    }\n\n    evtSource.close();\n  });\n};\n\n/**\n * Helper to parse backend dict-like payloads\n * @param {string} raw - Raw data from event\n * @returns {Object|null} Parsed object or null\n */\nconst parseBest = (raw) => {\n  if (!raw) {\n    return null;\n  }\n  const s = String(raw).trim();\n  try {\n    return JSON.parse(s);\n  } catch (_) {}\n  try {\n    // Best-effort convert Python dict repr to JSON\n    let t = s\n      .replace(/'/g, '\"')\n      .replace(/\\bNone\\b/g, \"null\")\n      .replace(/\\bTrue\\b/g, \"true\")\n      .replace(/\\bFalse\\b/g, \"false\");\n    return JSON.parse(t);\n  } catch (_) {\n    return null;\n  }\n};\n\n/**\n * Add status message to the execution container with proper scrolling\n * @param {string} message - Status message\n * @param {string} type - Status type (info, ok, error)\n * @param {Element} container - Container element\n */\nconst addStatus = (message, type, container) => {\n  const statusDiv = document.createElement(\"div\");\n  const alertClassMap = {\n    success: \"success\",\n    error: \"danger\",\n    info: \"info\"\n  };\n\n  statusDiv.className = `alert alert-${alertClassMap[type] || \"info\"} mb-2`;\n  statusDiv.innerHTML = `<small>${message}</small>`;\n  container.appendChild(statusDiv);\n\n  // Only auto-scroll if user hasn't manually scrolled\n  if (!userHasScrolled) {\n    const modalBody = document.querySelector(\".modal-body\");\n    if (modalBody) {\n      modalBody.scrollTop = modalBody.scrollHeight;\n    } else {\n      container.scrollTop = container.scrollHeight;\n    }\n  }\n};\n\n/**\n * Start execution streaming from the provided URL\n * @param {string} streamingUrl - The EventSource URL for streaming\n * @param {Element} container - Container element for displaying results\n * @param {number} courseid - The course ID for creating the course\n * @returns {Promise} Promise that resolves when streaming is complete\n */\nexport const startExecutionStreaming = async (\n  streamingUrl,\n  container,\n  courseid\n) => {\n  const progressIndicator = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming/progress']\"\n  );\n  const eventList = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming']\"\n  );\n  const progressIcon = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming/progress/icon']\"\n  );\n\n  eventList.innerHTML = \"\";\n  if (progressIndicator) {\n    progressIndicator.style.display = \"block\";\n  }\n\n  // Reset scroll state for execution streaming\n  userHasScrolled = false;\n  if (scrollTimeout) {\n    clearTimeout(scrollTimeout);\n    scrollTimeout = null;\n  }\n\n  // Setup scroll detection on modal body\n  const modalBody = document.querySelector(\".modal-body\");\n  if (modalBody) {\n    setupScrollDetection(modalBody);\n  }\n\n  const es = new EventSource(streamingUrl);\n\n  const onActStart = async (e) => {\n    const obj = parseBest(e.data) || {};\n    const idx = obj.index ?? \"?\";\n    const title = obj.title || \"\";\n    const sec = obj.section_index ?? \"?\";\n    const msg = await get_string(\n      \"execution_activity_start\",\n      \"local_datacurso\",\n      {\n        index: idx,\n        section: sec,\n        title: title,\n      }\n    );\n    addStatus(msg, \"info\", eventList);\n  };\n\n  const onActDone = async (e) => {\n    const obj = parseBest(e.data) || {};\n    const done = obj.done ?? 0;\n    const total = obj.total ?? 0;\n    const percent = obj.percent ?? 0;\n    const msg = await get_string(\"execution_activity_done\", \"local_datacurso\", {\n      done,\n      total,\n      percent,\n    });\n    addStatus(msg, \"ok\", eventList);\n  };\n\n  const onProgress = async (e) => {\n    const obj = parseBest(e.data) || {};\n    const done = obj.done ?? 0;\n    const total = obj.total ?? 0;\n    const percent = obj.percent ?? 0;\n    const msg = await get_string(\"execution_progress\", \"local_datacurso\", {\n      done,\n      total,\n      percent,\n    });\n    addStatus(msg, \"info\", eventList);\n  };\n\n  const onExecError = async () => {\n    const msg = await get_string(\"execution_error_activity\", \"local_datacurso\");\n    addStatus(msg, \"error\", eventList);\n  };\n\n  const onComplete = async () => {\n    // Close the EventSource connection first\n    es.close();\n    progressIcon.innerHTML = `\n        <div class=\"bg-success rounded-circle d-flex align-items-center justify-content-center\"\n              style=\"width: 1.5rem; height: 1.5rem;\">\n          <i class=\"text-white\" style=\"font-size: 0.8rem;\">✓</i>\n        </div>\n      `;\n\n    // Call createCourse to apply the AI-generated content\n    try {\n      const result = await createCourse({ courseid });\n\n      if (result.success) {\n        const okmsg = await get_string(\n          \"course_created_success_simple\",\n          \"local_datacurso\"\n        );\n        addStatus(okmsg, \"ok\", eventList);\n        // Reload the page after 500ms\n        setTimeout(() => {\n          window.location.reload();\n        }, 500);\n      } else {\n        const errmsg = await get_string(\n          \"error_creating_course\",\n          \"local_datacurso\",\n          result.message || \"\"\n        );\n        addStatus(errmsg, \"error\", eventList);\n      }\n    } catch (error) {\n      const errmsg = await get_string(\n        \"error_creating_course\",\n        \"local_datacurso\",\n        error.message || \"\"\n      );\n      addStatus(errmsg, \"error\", eventList);\n    }\n  };\n\n  // Register event listeners\n  es.addEventListener(\"execution_activity_start\", onActStart);\n  es.addEventListener(\"execution_activity_done\", onActDone);\n  es.addEventListener(\"execution_progress\", onProgress);\n  es.addEventListener(\"execution_error\", onExecError);\n  es.addEventListener(\"execution_complete\", onComplete);\n};\n"],"names":["userHasScrolled","scrollTimeout","setupScrollDetection","scrollContainer","addEventListener","element","clearTimeout","scrollTop","clientHeight","scrollHeight","setTimeout","passive","async","streamingUrl","container","isCorrection","progressIndicator","querySelector","eventList","progressIcon","htmlBuffer","rafPending","innerHTML","style","display","modalBody","document","acceptBtn","getElementById","adjustBtn","disabled","updateHtmlSoon","requestAnimationFrame","appendToken","token","evtSource","EventSource","event","data","planningActions","close","parseBest","raw","s","String","trim","JSON","parse","_","t","replace","addStatus","message","type","statusDiv","createElement","className","success","error","info","appendChild","courseid","es","obj","e","idx","index","title","sec","section_index","msg","section","done","total","percent","result","okmsg","window","location","reload","errmsg"],"mappings":"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"}