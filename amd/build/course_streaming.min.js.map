{"version":3,"file":"course_streaming.min.js","sources":["../src/course_streaming.js"],"sourcesContent":["/* eslint-disable */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Course Streaming Module for handling real-time course generation\n *\n * @module     local_datacurso/course_streaming\n * @copyright  2025 Buendata <soluciones@buendata.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport { createCourse } from \"local_datacurso/repository/chatbot\";\nimport { get_string } from \"core/str\";\n\n// Global state for scroll behavior\nlet userHasScrolled = false;\nlet scrollTimeout = null;\n\n/**\n * Check if user is at the bottom of the scrollable container\n * @param {Element} element - The scrollable element\n * @returns {boolean} - True if user is at bottom\n */\nconst isAtBottom = (element) => {\n  const threshold = 50; // 50px threshold\n  return element.scrollTop + element.clientHeight >= element.scrollHeight - threshold;\n};\n\n/**\n * Setup scroll detection to pause auto-scroll when user scrolls manually\n * @param {Element} scrollContainer - The container to monitor for scroll\n */\nconst setupScrollDetection = (scrollContainer) => {\n  if (!scrollContainer) return;\n  \n  const handleScroll = () => {\n    // Clear existing timeout\n    if (scrollTimeout) {\n      clearTimeout(scrollTimeout);\n    }\n    \n    // Mark that user has scrolled\n    userHasScrolled = true;\n    \n    // Check if user scrolled back to bottom\n    if (isAtBottom(scrollContainer)) {\n      // Reset flag after a short delay to resume auto-scroll\n      scrollTimeout = setTimeout(() => {\n        userHasScrolled = false;\n      }, 1000);\n    }\n  };\n  \n  scrollContainer.addEventListener('scroll', handleScroll, { passive: true });\n};\n\n/**\n * Start course streaming from the provided URL\n * @param {string} streamingUrl - The EventSource URL for streaming\n * @param {Element} container - Container element for displaying results\n * @param {boolean} isCorrection - Whether this is a plan correction (don't clear existing content)\n * @returns {Promise} Promise that resolves when streaming is complete\n */\nexport const startStreaming = async (streamingUrl, container, isCorrection = false) => {\n  const progressIndicator = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming/progress']\"\n  );\n  const eventList = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming']\"\n  );\n  const progressIcon = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming/progress/icon']\"\n  );\n\n  // Create local buffer and RAF state for this streaming instance\n  let htmlBuffer = \"\";\n  let rafPending = false;\n\n  // Only clear content if this is not a correction\n  if (!isCorrection) {\n    eventList.innerHTML = \"\";\n  }\n  if (progressIndicator) {\n    progressIndicator.style.display = \"block\";\n  }\n\n  // Reset scroll state for new streaming session\n  userHasScrolled = false;\n  if (scrollTimeout) {\n    clearTimeout(scrollTimeout);\n    scrollTimeout = null;\n  }\n\n  // Setup scroll detection on modal body\n  const modalBody = document.querySelector('.modal-body');\n  if (modalBody) {\n    setupScrollDetection(modalBody);\n  }\n\n  // Disable both planning buttons during streaming\n  const acceptBtn = document.getElementById(\"accept-planning-btn\");\n  const adjustBtn = document.getElementById(\"adjust-planning-btn\");\n  if (acceptBtn) {\n    acceptBtn.disabled = true;\n  }\n  if (adjustBtn) {\n    adjustBtn.disabled = true;\n  }\n\n  // Local functions for this streaming instance\n  const updateHtmlSoon = (container) => {\n    if (rafPending) return;\n    rafPending = true;\n    requestAnimationFrame(() => {\n      rafPending = false;\n      container.innerHTML = htmlBuffer;\n      // Only auto-scroll if user hasn't manually scrolled\n      if (!userHasScrolled) {\n        const modalBody = document.querySelector('.modal-body');\n        if (modalBody) {\n          modalBody.scrollTop = modalBody.scrollHeight;\n        } else {\n          container.scrollTop = container.scrollHeight;\n        }\n      }\n    });\n  };\n\n  const appendToken = (token, container) => {\n    htmlBuffer += token;\n    updateHtmlSoon(container);\n  };\n\n  const evtSource = new EventSource(streamingUrl);\n\n  evtSource.addEventListener(\"assistant_token\", (event) => {\n    appendToken(event.data, eventList);\n  });\n\n  evtSource.addEventListener(\"assistant_message_end\", () => {\n    progressIcon.innerHTML = `\n        <div class=\"bg-success rounded-circle d-flex align-items-center justify-content-center\" style=\"width: 1.5rem; height: 1.5rem;\">\n          <i class=\"text-white\" style=\"font-size: 0.8rem;\">✓</i>\n        </div>\n      `;\n    const planningActions = document.getElementById(\"course-planning-actions\");\n    if (planningActions) {\n      planningActions.style.display = \"block\";\n    }\n    \n    // Re-enable both planning buttons after streaming completes\n    const acceptBtn = document.getElementById(\"accept-planning-btn\");\n    const adjustBtn = document.getElementById(\"adjust-planning-btn\");\n    if (acceptBtn) {\n      acceptBtn.disabled = false;\n    }\n    if (adjustBtn) {\n      adjustBtn.disabled = false;\n    }\n    \n    evtSource.close();\n  });\n};\n\n/**\n * Helper to parse backend dict-like payloads\n * @param {string} raw - Raw data from event\n * @returns {Object|null} Parsed object or null\n */\nconst parseBest = (raw) => {\n  if (!raw) return null;\n  const s = String(raw).trim();\n  try {\n    return JSON.parse(s);\n  } catch (_) {}\n  try {\n    // Best-effort convert Python dict repr to JSON\n    let t = s\n      .replace(/'/g, '\"')\n      .replace(/\\bNone\\b/g, \"null\")\n      .replace(/\\bTrue\\b/g, \"true\")\n      .replace(/\\bFalse\\b/g, \"false\");\n    return JSON.parse(t);\n  } catch (_) {\n    return null;\n  }\n};\n\n/**\n * Add status message to the execution container with proper scrolling\n * @param {string} message - Status message\n * @param {string} type - Status type (info, ok, error)\n * @param {Element} container - Container element\n */\nconst addStatus = (message, type, container) => {\n  const statusDiv = document.createElement(\"div\");\n  statusDiv.className = `alert alert-${\n    type === \"ok\" ? \"success\" : type === \"error\" ? \"danger\" : \"info\"\n  } mb-2`;\n  statusDiv.innerHTML = `<small>${message}</small>`;\n  container.appendChild(statusDiv);\n  \n  // Only auto-scroll if user hasn't manually scrolled\n  if (!userHasScrolled) {\n    const modalBody = document.querySelector('.modal-body');\n    if (modalBody) {\n      modalBody.scrollTop = modalBody.scrollHeight;\n    } else {\n      container.scrollTop = container.scrollHeight;\n    }\n  }\n};\n\n/**\n * Start execution streaming from the provided URL\n * @param {string} streamingUrl - The EventSource URL for streaming\n * @param {Element} container - Container element for displaying results\n * @returns {Promise} Promise that resolves when streaming is complete\n */\nexport const startExecutionStreaming = async (\n  streamingUrl,\n  container,\n  courseid\n) => {\n  const progressIndicator = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming/progress']\"\n  );\n  const eventList = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming']\"\n  );\n  const progressIcon = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming/progress/icon']\"\n  );\n\n  console.log({ container, progressIndicator, eventList, progressIcon });\n  eventList.innerHTML = \"\";\n  if (progressIndicator) {\n    progressIndicator.style.display = \"block\";\n  }\n\n  // Reset scroll state for execution streaming\n  userHasScrolled = false;\n  if (scrollTimeout) {\n    clearTimeout(scrollTimeout);\n    scrollTimeout = null;\n  }\n\n  // Setup scroll detection on modal body\n  const modalBody = document.querySelector('.modal-body');\n  if (modalBody) {\n    setupScrollDetection(modalBody);\n  }\n\n  const es = new EventSource(streamingUrl);\n\n  const onActStart = async (e) => {\n    console.log(\"onActStart\", e);\n    const obj = parseBest(e.data) || {};\n    const idx = obj.index ?? \"?\";\n    const title = obj.title || \"\";\n    const sec = obj.section_index ?? \"?\";\n    const msg = await get_string(\"execution_activity_start\", \"local_datacurso\", {\n      index: idx,\n      section: sec,\n      title: title,\n    });\n    addStatus(msg, \"info\", eventList);\n  };\n\n  const onActDone = async (e) => {\n    console.log(\"onActDone\", e);\n    const obj = parseBest(e.data) || {};\n    const done = obj.done ?? 0;\n    const total = obj.total ?? 0;\n    const percent = obj.percent ?? 0;\n    const msg = await get_string(\"execution_activity_done\", \"local_datacurso\", {\n      done,\n      total,\n      percent,\n    });\n    addStatus(msg, \"ok\", eventList);\n  };\n\n  const onProgress = async (e) => {\n    console.log(\"onProgress\", e);\n    const obj = parseBest(e.data) || {};\n    const done = obj.done ?? 0;\n    const total = obj.total ?? 0;\n    const percent = obj.percent ?? 0;\n    const msg = await get_string(\"execution_progress\", \"local_datacurso\", {\n      done,\n      total,\n      percent,\n    });\n    addStatus(msg, \"info\", eventList);\n  };\n\n  const onExecError = async (e) => {\n    console.log(\"onExecError\", e);\n    const msg = await get_string(\"execution_error_activity\", \"local_datacurso\");\n    addStatus(msg, \"error\", eventList);\n  };\n\n  const onComplete = async (e) => {\n    console.log(\"onComplete\", e);\n\n    // Close the EventSource connection first\n    es.close();\n    progressIcon.innerHTML = `\n        <div class=\"bg-success rounded-circle d-flex align-items-center justify-content-center\" style=\"width: 1.5rem; height: 1.5rem;\">\n          <i class=\"text-white\" style=\"font-size: 0.8rem;\">✓</i>\n        </div>\n      `;\n\n    // Call createCourse to apply the AI-generated content\n    try {\n      const result = await createCourse({ courseid });\n\n      if (result.success) {\n        const okmsg = await get_string(\"course_created_success_simple\", \"local_datacurso\");\n        addStatus(okmsg, \"ok\", eventList);\n        // Reload the page after 500ms\n        setTimeout(() => {\n          window.location.reload();\n        }, 500);\n      } else {\n        const errmsg = await get_string(\"error_creating_course\", \"local_datacurso\", result.message || \"\");\n        addStatus(errmsg, \"error\", eventList);\n      }\n    } catch (error) {\n      const errmsg = await get_string(\"error_creating_course\", \"local_datacurso\", error.message || \"\");\n      addStatus(errmsg, \"error\", eventList);\n    }\n  };\n\n  // Register event listeners\n  es.addEventListener(\"execution_activity_start\", onActStart);\n  es.addEventListener(\"execution_activity_done\", onActDone);\n  es.addEventListener(\"execution_progress\", onProgress);\n  es.addEventListener(\"execution_error\", onExecError);\n  es.addEventListener(\"execution_complete\", onComplete);\n};\n\n"],"names":["userHasScrolled","scrollTimeout","setupScrollDetection","scrollContainer","addEventListener","element","clearTimeout","scrollTop","clientHeight","scrollHeight","setTimeout","passive","async","streamingUrl","container","isCorrection","progressIndicator","querySelector","eventList","progressIcon","htmlBuffer","rafPending","innerHTML","style","display","modalBody","document","acceptBtn","getElementById","adjustBtn","disabled","updateHtmlSoon","requestAnimationFrame","appendToken","token","evtSource","EventSource","event","data","planningActions","close","parseBest","raw","s","String","trim","JSON","parse","_","t","replace","addStatus","message","type","statusDiv","createElement","className","appendChild","courseid","console","log","es","e","obj","idx","index","title","sec","section_index","msg","section","done","total","percent","result","success","okmsg","window","location","reload","errmsg","error"],"mappings":"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"}