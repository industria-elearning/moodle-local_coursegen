{"version":3,"file":"add_course_ai_modal.min.js","sources":["../src/add_course_ai_modal.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Course AI Modal Module using Moodle's modal factory\n *\n * @module     local_datacurso/add_course_ai_modal\n * @copyright  2025 Wilber Narvaez <https://datacurso.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Modal from \"core/modal\";\nimport Templates from \"core/templates\";\nimport Notification from \"core/notification\";\nimport { get_string } from \"core/str\";\nimport {\n  startStreaming,\n  startExecutionStreaming,\n} from \"local_datacurso/course_streaming\";\nimport {\n  planCourseMessage,\n  planCourseExecute,\n} from \"local_datacurso/repository/chatbot\";\n\nlet currentModal = null;\n\n// Global state for scroll behavior\nlet userHasScrolled = false;\nlet scrollTimeout = null;\n\n/**\n * Check if user is at the bottom of the scrollable container\n * @param {Element} element - The scrollable element\n * @returns {boolean} - True if user is at bottom\n */\nconst isAtBottom = (element) => {\n  const threshold = 50; // 50px threshold\n  return (\n    element.scrollTop + element.clientHeight >= element.scrollHeight - threshold\n  );\n};\n\n/**\n * Setup scroll detection to pause auto-scroll when user scrolls manually\n * @param {Element} scrollContainer - The container to monitor for scroll\n */\nconst setupScrollDetection = (scrollContainer) => {\n  if (!scrollContainer) {\n    return;\n  }\n\n  const handleScroll = () => {\n    // Clear existing timeout\n    if (scrollTimeout) {\n      clearTimeout(scrollTimeout);\n    }\n\n    // Mark that user has scrolled\n    userHasScrolled = true;\n\n    // Check if user scrolled back to bottom\n    if (isAtBottom(scrollContainer)) {\n      // Reset flag after a short delay to resume auto-scroll\n      scrollTimeout = setTimeout(() => {\n        userHasScrolled = false;\n      }, 1000);\n    }\n  };\n\n  scrollContainer.addEventListener(\"scroll\", handleScroll, { passive: true });\n};\n\n/**\n * Initialize and show the course AI modal\n * @param {Object} params - Parameters object\n * @param {string} params.streamingurl - The complete URL for course streaming (including session)\n * @returns {Promise}\n */\nexport const init = async (params = {}) => {\n  try {\n    // Close existing modal if open\n    if (currentModal) {\n      currentModal.destroy();\n      currentModal = null;\n    }\n\n    // Get modal title and body content\n    const [title, bodyHTML, footerHTML] = await Promise.all([\n      get_string(\"addcourseai_modaltitle\", \"local_datacurso\"),\n      Templates.render(\"local_datacurso/add_course_ai_modal\", {}),\n      Templates.render(\"local_datacurso/add_course_ai_modal_footer\", {}),\n    ]);\n\n    // Create modal using modern Modal class\n    currentModal = await Modal.create({\n      title: title,\n      body: bodyHTML,\n      footer: footerHTML,\n      large: true,\n      scrollable: true,\n      removeOnClose: true,\n    });\n\n    currentModal.getRoot().addClass(\"local_datacurso_course_ai_modal\");\n\n    currentModal.show();\n\n    const bodyEl = currentModal.getBody()[0];\n\n    // Reset scroll state and setup detection\n    userHasScrolled = false;\n    if (scrollTimeout) {\n      clearTimeout(scrollTimeout);\n      scrollTimeout = null;\n    }\n\n    // Setup scroll detection on modal body\n    const modalBody = currentModal.getBody()[0];\n    if (modalBody) {\n      setupScrollDetection(modalBody);\n    }\n\n    initializeChatInterface(bodyEl, params);\n    setupPlanningButtons(bodyEl, params);\n    setupPlanningToggle(bodyEl);\n    return currentModal;\n  } catch (error) {\n    Notification.exception(error);\n    return null;\n  }\n};\n\n/**\n * Initialize the chat interface\n * @param {Element} container - The modal container element\n * @param {Object} params - The parameters including streaming URL\n */\nconst initializeChatInterface = async (container, params) => {\n  // Find the streaming button and add event listener\n  try {\n    // Ensure chat interface is hidden when (re)starting streaming\n    const chatInterface = container.querySelector(\"#course-chat-interface\");\n    if (chatInterface) {\n      chatInterface.style.display = \"none\";\n    }\n\n    // Start streaming with the URL provided by PHP (already includes session)\n    await startStreaming(params.streamingurl, container);\n  } catch (error) {\n    Notification.exception(error);\n  }\n};\n\n/**\n * Add user message bubble\n * @param {Element} wrap - Messages container\n * @param {string} text - Message text\n */\nconst pushUser = (wrap, text) => addBubble(wrap, text, \"user\");\n\n/**\n * Add message bubble\n * @param {Element} wrap - Messages container\n * @param {string} text - Message text\n * @param {string} role - Message role (user/ai)\n */\nconst addBubble = (wrap, text, role) => {\n  const row = document.createElement(\"div\");\n  row.className = `local_datacurso_ai_msg ${role}`;\n  const bubble = document.createElement(\"div\");\n  bubble.className = \"bubble\";\n  bubble.textContent = text;\n  row.appendChild(bubble);\n  wrap.appendChild(row);\n  scrollToBottom(wrap);\n};\n\n/**\n * Scroll messages to bottom smoothly - only if user hasn't scrolled\n * @param {Element} wrap - Messages container\n */\nconst scrollToBottom = (wrap) => {\n  if (!userHasScrolled) {\n    const modalBody = document.querySelector(\".modal-body\");\n    if (modalBody) {\n      modalBody.scrollTop = modalBody.scrollHeight;\n    } else {\n      wrap.scrollTop = wrap.scrollHeight;\n    }\n  }\n};\n\n/**\n * Muestra texto con efecto \"máquina de escribir\" dentro de un elemento,\n * manteniendo el scroll automático si el usuario no ha intervenido.\n *\n * @param {HTMLElement} element - Elemento destino donde se escribe el texto.\n * @param {string} text - Texto completo a mostrar.\n * @param {number} speed - Intervalo en milisegundos entre cada carácter.\n * @param {HTMLElement} [scrollContainer=document.querySelector('.modal-body')] - Contenedor a auto-scroll.\n * @returns {Promise<void>} - Se resuelve al completar la escritura.\n */\nasync function typeWriter(\n  element,\n  text,\n  speed,\n  scrollContainer = document.querySelector(\".modal-body\")\n) {\n  if (!element || typeof text !== \"string\") {\n    return;\n  }\n\n  let index = 0;\n  let userHasScrolled = false;\n\n  // Detecta si el usuario ha hecho scroll manualmente\n  if (scrollContainer) {\n    const onUserScroll = () => {\n      userHasScrolled = true;\n      scrollContainer.removeEventListener(\"scroll\", onUserScroll);\n    };\n    scrollContainer.addEventListener(\"scroll\", onUserScroll);\n  }\n\n  // Escribe carácter por carácter\n  while (index < text.length) {\n    element.textContent += text[index++];\n\n    if (scrollContainer && !userHasScrolled) {\n      scrollContainer.scrollTop = scrollContainer.scrollHeight;\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, speed));\n  }\n}\n\n/**\n * Collapse the planning phase and show summary\n * @param {Element} container - The modal container element\n */\nconst collapsePlanningPhase = (container) => {\n  const planningPhase = container.querySelector(\"#planning-phase-section\");\n  const planningSummary = container.querySelector(\n    \"#planning-summary-collapsed\"\n  );\n  const planningDetailsContent = container.querySelector(\n    \"#planning-details-content\"\n  );\n\n  if (planningPhase && planningSummary && planningDetailsContent) {\n    // Move planning content to collapsed section\n    const planningContent = planningPhase.innerHTML;\n    planningDetailsContent.innerHTML = planningContent;\n\n    // Hide planning phase and show summary\n    planningPhase.style.display = \"none\";\n    planningSummary.style.display = \"block\";\n  }\n};\n\n/**\n * Setup collapsible planning details toggle\n * @param {Element} container - The modal container element\n */\nconst setupPlanningToggle = (container) => {\n  const toggleBtn = container.querySelector(\"#toggle-planning-details\");\n  const collapseElement = container.querySelector(\"#planning-details-collapse\");\n  const toggleIcon = container.querySelector(\"#planning-toggle-icon\");\n\n  if (toggleBtn && collapseElement && toggleIcon) {\n    toggleBtn.addEventListener(\"click\", () => {\n      const isCollapsed = !collapseElement.classList.contains(\"show\");\n\n      if (isCollapsed) {\n        collapseElement.classList.add(\"show\");\n        toggleIcon.classList.remove(\"fa-chevron-down\");\n        toggleIcon.classList.add(\"fa-chevron-up\");\n      } else {\n        collapseElement.classList.remove(\"show\");\n        toggleIcon.classList.remove(\"fa-chevron-up\");\n        toggleIcon.classList.add(\"fa-chevron-down\");\n      }\n    });\n  }\n};\n\n/**\n * Setup planning buttons event handlers\n * @param {Element} container - The modal container element\n * @param {Object} params - The parameters including course ID\n */\nconst setupPlanningButtons = (container, params) => {\n  const acceptBtn = container.querySelector(\"#accept-planning-btn\");\n  const adjustBtn = container.querySelector(\"#adjust-planning-btn\");\n  const chatInterface = container.querySelector(\"#course-chat-interface\");\n  const chatForm = container.querySelector(\"#course-chat-form\");\n  const chatInput = container.querySelector(\"#courseChatInput\");\n  const streamingContainer = container.querySelector(\n    \"[data-region='local_datacurso/course_streaming']\"\n  );\n\n  if (acceptBtn) {\n    acceptBtn.addEventListener(\"click\", async () => {\n      // Disable button to prevent double clicks\n      acceptBtn.disabled = true;\n      acceptBtn.textContent = await get_string(\n        \"creating_course\",\n        \"local_datacurso\"\n      );\n\n      try {\n        // Extract course ID from streaming URL or use params.courseid\n        const courseId = params.courseid;\n\n        if (!courseId) {\n          throw new Error(\n            await get_string(\"error_no_course_id\", \"local_datacurso\")\n          );\n        }\n\n        // Call the plan course execute webservice\n        const response = await planCourseExecute(courseId);\n\n        if (!response.success) {\n          throw new Error(\n            response.message ||\n              (await get_string(\"error_executing_plan\", \"local_datacurso\"))\n          );\n        }\n\n        // Hide planning buttons since execution has started\n        const planningActions = container.querySelector(\n          \"#course-planning-actions\"\n        );\n        if (planningActions) {\n          planningActions.style.display = \"none\";\n        }\n\n        // Collapse planning phase and show execution phase\n        collapsePlanningPhase(container);\n\n        // Get execution container\n        const executionContainer = container.querySelector(\n          \"#execution-phase-container\"\n        );\n\n        // Start execution streaming\n        if (response.data && response.data.streamingurl && executionContainer) {\n          // Create streaming block template with execution-specific texts\n          const html = await Templates.render(\n            \"local_datacurso/course_streaming_inline\",\n            {\n              title: await get_string(\n                \"course_creating_title\",\n                \"local_datacurso\"\n              ),\n              subtitle: await get_string(\n                \"course_creating_subtitle\",\n                \"local_datacurso\"\n              ),\n            }\n          );\n          const temp = document.createElement(\"div\");\n          temp.innerHTML = html;\n          const streamingBlock = temp.firstElementChild;\n          executionContainer.appendChild(streamingBlock);\n          await startExecutionStreaming(\n            response.data.streamingurl,\n            streamingBlock,\n            courseId\n          );\n        }\n\n        // Show success notification after execution completes\n        const message = await get_string(\"addcourseai_done\", \"local_datacurso\");\n        Notification.addNotification({\n          message: message,\n          type: \"success\",\n        });\n      } catch (error) {\n        acceptBtn.disabled = false;\n        acceptBtn.textContent = await get_string(\n          \"accept_planning_create_course\",\n          \"local_datacurso\"\n        );\n        Notification.exception(error);\n      }\n    });\n  }\n\n  if (adjustBtn) {\n    adjustBtn.addEventListener(\"click\", () => {\n      // Disable button to prevent double clicks\n      adjustBtn.disabled = true;\n\n      // Show chat interface\n      if (chatInterface) {\n        chatInterface.style.display = \"block\";\n        chatInput.focus();\n      }\n    });\n  }\n\n  // Add Enter key support for chat input\n  if (chatInput) {\n    chatInput.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        if (chatForm) {\n          chatForm.dispatchEvent(new Event(\"submit\"));\n        }\n      }\n    });\n  }\n\n  if (chatForm) {\n    chatForm.addEventListener(\"submit\", async (e) => {\n      e.preventDefault();\n\n      const message = chatInput.value.trim();\n      if (!message) {\n        return;\n      }\n\n      // Check if streamingContainer exists\n      if (!streamingContainer) {\n        return;\n      }\n\n      // Add user message bubble to streaming container\n      pushUser(streamingContainer, message);\n\n      // Clear input\n      chatInput.value = \"\";\n\n      // Disable form while processing\n      const submitBtn = chatForm.querySelector('button[type=\"submit\"]');\n      submitBtn.disabled = true;\n\n      try {\n        // Call the plan_course_message via repository\n        const response = await planCourseMessage({\n          courseid: params.courseid,\n          text: message,\n        });\n\n        if (!response.success) {\n          // Add error message as streaming text\n          const errorResponse = document.createElement(\"div\");\n          errorResponse.className = \"mb-3 text-danger\";\n          streamingContainer.appendChild(errorResponse);\n          const errorMsg =\n            response.message ||\n            (await get_string(\"error_processing_request\", \"local_datacurso\"));\n          await typeWriter(errorResponse, errorMsg, 15);\n          return;\n        }\n\n        // If backend returns a streaming URL, render an inline streaming block and start streaming\n        const streamingUrl = response.data.streamingurl;\n        if (streamingUrl) {\n          // Hide chat interface when a new streaming session starts\n          if (chatInterface) {\n            chatInterface.style.display = \"none\";\n          }\n\n          // Add a separator to distinguish the correction from previous content\n          const separator = document.createElement(\"div\");\n          separator.className = \"mt-4 mb-3 border-top pt-3\";\n          const correctionText = await get_string(\n            \"adjust_planning_title\",\n            \"local_datacurso\"\n          );\n          separator.innerHTML = `<h6 class=\"text-muted\"><i class=\"fa fa-edit\"></i> ${correctionText}</h6>`;\n          streamingContainer.appendChild(separator);\n\n          const html = await Templates.render(\n            \"local_datacurso/course_streaming_inline\",\n            {}\n          );\n          const temp = document.createElement(\"div\");\n          temp.innerHTML = html;\n          const streamingBlock = temp.firstElementChild;\n          streamingContainer.appendChild(streamingBlock);\n          await startStreaming(streamingUrl, streamingBlock, true); // Pass true to indicate this is a correction\n        }\n      } catch (error) {\n        // Add error message as streaming text\n        const errorResponse = document.createElement(\"div\");\n        errorResponse.className = \"mb-3 text-danger\";\n        streamingContainer.appendChild(errorResponse);\n        const errorMsg = await get_string(\n          \"error_sending_message\",\n          \"local_datacurso\"\n        );\n        await typeWriter(errorResponse, `${errorMsg}: ${error.message}`, 15);\n      } finally {\n        submitBtn.disabled = false;\n      }\n    });\n  }\n};\n"],"names":["currentModal","userHasScrolled","scrollTimeout","setupScrollDetection","scrollContainer","addEventListener","element","clearTimeout","scrollTop","clientHeight","scrollHeight","setTimeout","passive","async","params","destroy","title","bodyHTML","footerHTML","Promise","all","Templates","render","Modal","create","body","footer","large","scrollable","removeOnClose","getRoot","addClass","show","bodyEl","getBody","modalBody","initializeChatInterface","setupPlanningButtons","setupPlanningToggle","error","exception","container","chatInterface","querySelector","style","display","streamingurl","addBubble","wrap","text","role","row","document","createElement","className","bubble","textContent","appendChild","scrollToBottom","typeWriter","speed","index","onUserScroll","removeEventListener","length","resolve","toggleBtn","collapseElement","toggleIcon","classList","contains","add","remove","acceptBtn","adjustBtn","chatForm","chatInput","streamingContainer","disabled","courseId","courseid","Error","response","success","message","planningActions","planningPhase","planningSummary","planningDetailsContent","planningContent","innerHTML","collapsePlanningPhase","executionContainer","data","html","subtitle","temp","streamingBlock","firstElementChild","addNotification","type","focus","e","key","shiftKey","preventDefault","dispatchEvent","Event","value","trim","submitBtn","errorResponse","errorMsg","streamingUrl","separator","correctionText"],"mappings":";;;;;;;8NAoCIA,aAAe,KAGfC,iBAAkB,EAClBC,cAAgB,WAkBdC,qBAAwBC,sBACvBA,uBAsBLA,gBAAgBC,iBAAiB,UAlBZ,KAhBHC,IAAAA,QAkBZJ,eACFK,aAAaL,eAIfD,iBAAkB,GAvBFK,QA0BDF,iBAvBPI,UAAYF,QAAQG,cAAgBH,QAAQI,aAFpC,KA2BdR,cAAgBS,YAAW,KACzBV,iBAAkB,IACjB,QAIkD,CAAEW,SAAS,mBASlDC,qBAAOC,8DAAS,OAG5Bd,eACFA,aAAae,UACbf,aAAe,YAIVgB,MAAOC,SAAUC,kBAAoBC,QAAQC,IAAI,EACtD,mBAAW,yBAA0B,mBACrCC,mBAAUC,OAAO,sCAAuC,IACxDD,mBAAUC,OAAO,6CAA8C,MAIjEtB,mBAAqBuB,eAAMC,OAAO,CAChCR,MAAOA,MACPS,KAAMR,SACNS,OAAQR,WACRS,OAAO,EACPC,YAAY,EACZC,eAAe,IAGjB7B,aAAa8B,UAAUC,SAAS,mCAEhC/B,aAAagC,aAEPC,OAASjC,aAAakC,UAAU,GAGtCjC,iBAAkB,EACdC,gBACFK,aAAaL,eACbA,cAAgB,YAIZiC,UAAYnC,aAAakC,UAAU,UACrCC,WACFhC,qBAAqBgC,WAGvBC,wBAAwBH,OAAQnB,QAChCuB,qBAAqBJ,OAAQnB,QAC7BwB,oBAAoBL,QACbjC,aACP,MAAOuC,oCACMC,UAAUD,OAChB,aASLH,wBAA0BvB,MAAO4B,UAAW3B,oBAIxC4B,cAAgBD,UAAUE,cAAc,0BAC1CD,gBACFA,cAAcE,MAAMC,QAAU,cAI1B,oCAAe/B,OAAOgC,aAAcL,WAC1C,MAAOF,6BACMC,UAAUD,SAiBrBQ,UAAY,CAACC,KAAMC,KAAMC,cACvBC,IAAMC,SAASC,cAAc,OACnCF,IAAIG,2CAAsCJ,YACpCK,OAASH,SAASC,cAAc,OACtCE,OAAOD,UAAY,SACnBC,OAAOC,YAAcP,KACrBE,IAAIM,YAAYF,QAChBP,KAAKS,YAAYN,KACjBO,eAAeV,OAOXU,eAAkBV,WACjB/C,gBAAiB,OACdkC,UAAYiB,SAAST,cAAc,eACrCR,UACFA,UAAU3B,UAAY2B,UAAUzB,aAEhCsC,KAAKxC,UAAYwC,KAAKtC,8BAebiD,WACbrD,QACA2C,KACAW,WACAxD,uEAAkBgD,SAAST,cAAc,mBAEpCrC,SAA2B,iBAAT2C,gBAInBY,MAAQ,EACR5D,iBAAkB,KAGlBG,gBAAiB,OACb0D,aAAe,KACnB7D,iBAAkB,EAClBG,gBAAgB2D,oBAAoB,SAAUD,eAEhD1D,gBAAgBC,iBAAiB,SAAUyD,mBAItCD,MAAQZ,KAAKe,QAClB1D,QAAQkD,aAAeP,KAAKY,SAExBzD,kBAAoBH,kBACtBG,gBAAgBI,UAAYJ,gBAAgBM,oBAGxC,IAAIS,SAAS8C,SAAYtD,WAAWsD,QAASL,eAgCjDtB,oBAAuBG,kBACrByB,UAAYzB,UAAUE,cAAc,4BACpCwB,gBAAkB1B,UAAUE,cAAc,8BAC1CyB,WAAa3B,UAAUE,cAAc,yBAEvCuB,WAAaC,iBAAmBC,YAClCF,UAAU7D,iBAAiB,SAAS,MACb8D,gBAAgBE,UAAUC,SAAS,SAGtDH,gBAAgBE,UAAUE,IAAI,QAC9BH,WAAWC,UAAUG,OAAO,mBAC5BJ,WAAWC,UAAUE,IAAI,mBAEzBJ,gBAAgBE,UAAUG,OAAO,QACjCJ,WAAWC,UAAUG,OAAO,iBAC5BJ,WAAWC,UAAUE,IAAI,wBAW3BlC,qBAAuB,CAACI,UAAW3B,gBACjC2D,UAAYhC,UAAUE,cAAc,wBACpC+B,UAAYjC,UAAUE,cAAc,wBACpCD,cAAgBD,UAAUE,cAAc,0BACxCgC,SAAWlC,UAAUE,cAAc,qBACnCiC,UAAYnC,UAAUE,cAAc,oBACpCkC,mBAAqBpC,UAAUE,cACnC,oDAGE8B,WACFA,UAAUpE,iBAAiB,SAASQ,UAElC4D,UAAUK,UAAW,EACrBL,UAAUjB,kBAAoB,mBAC5B,kBACA,6BAKMuB,SAAWjE,OAAOkE,aAEnBD,eACG,IAAIE,YACF,mBAAW,qBAAsB,0BAKrCC,eAAiB,8BAAkBH,cAEpCG,SAASC,cACN,IAAIF,MACRC,SAASE,eACA,mBAAW,uBAAwB,0BAK1CC,gBAAkB5C,UAAUE,cAChC,4BAEE0C,kBACFA,gBAAgBzC,MAAMC,QAAU,QA/FXJ,CAAAA,kBACvB6C,cAAgB7C,UAAUE,cAAc,2BACxC4C,gBAAkB9C,UAAUE,cAChC,+BAEI6C,uBAAyB/C,UAAUE,cACvC,gCAGE2C,eAAiBC,iBAAmBC,uBAAwB,OAExDC,gBAAkBH,cAAcI,UACtCF,uBAAuBE,UAAYD,gBAGnCH,cAAc1C,MAAMC,QAAU,OAC9B0C,gBAAgB3C,MAAMC,QAAU,UAmF5B8C,CAAsBlD,iBAGhBmD,mBAAqBnD,UAAUE,cACnC,iCAIEuC,SAASW,MAAQX,SAASW,KAAK/C,cAAgB8C,mBAAoB,OAE/DE,WAAazE,mBAAUC,OAC3B,0CACA,CACEN,YAAa,mBACX,wBACA,mBAEF+E,eAAgB,mBACd,2BACA,qBAIAC,KAAO5C,SAASC,cAAc,OACpC2C,KAAKN,UAAYI,WACXG,eAAiBD,KAAKE,kBAC5BN,mBAAmBnC,YAAYwC,sBACzB,6CACJf,SAASW,KAAK/C,aACdmD,eACAlB,gBAKEK,cAAgB,mBAAW,mBAAoB,yCACxCe,gBAAgB,CAC3Bf,QAASA,QACTgB,KAAM,YAER,MAAO7D,OACPkC,UAAUK,UAAW,EACrBL,UAAUjB,kBAAoB,mBAC5B,gCACA,yCAEWhB,UAAUD,WAKzBmC,WACFA,UAAUrE,iBAAiB,SAAS,KAElCqE,UAAUI,UAAW,EAGjBpC,gBACFA,cAAcE,MAAMC,QAAU,QAC9B+B,UAAUyB,YAMZzB,WACFA,UAAUvE,iBAAiB,WAAYiG,IACvB,UAAVA,EAAEC,KAAoBD,EAAEE,WAC1BF,EAAEG,iBACE9B,UACFA,SAAS+B,cAAc,IAAIC,MAAM,eAMrChC,UACFA,SAAStE,iBAAiB,UAAUQ,MAAAA,IAClCyF,EAAEG,uBAEIrB,QAAUR,UAAUgC,MAAMC,WAC3BzB,mBAKAP,0BA3QsB9B,UAgRlB8B,mBAAoBO,QAhRoB,QAmRjDR,UAAUgC,MAAQ,SAGZE,UAAYnC,SAAShC,cAAc,yBACzCmE,UAAUhC,UAAW,YAIbI,eAAiB,8BAAkB,CACvCF,SAAUlE,OAAOkE,SACjB/B,KAAMmC,cAGHF,SAASC,QAAS,OAEf4B,cAAgB3D,SAASC,cAAc,OAC7C0D,cAAczD,UAAY,mBAC1BuB,mBAAmBpB,YAAYsD,qBACzBC,SACJ9B,SAASE,eACF,mBAAW,2BAA4B,qCAC1CzB,WAAWoD,cAAeC,SAAU,UAKtCC,aAAe/B,SAASW,KAAK/C,gBAC/BmE,aAAc,CAEZvE,gBACFA,cAAcE,MAAMC,QAAU,cAI1BqE,UAAY9D,SAASC,cAAc,OACzC6D,UAAU5D,UAAY,kCAChB6D,qBAAuB,mBAC3B,wBACA,mBAEFD,UAAUxB,sEAAiEyB,wBAC3EtC,mBAAmBpB,YAAYyD,iBAEzBpB,WAAazE,mBAAUC,OAC3B,0CACA,IAEI0E,KAAO5C,SAASC,cAAc,OACpC2C,KAAKN,UAAYI,WACXG,eAAiBD,KAAKE,kBAC5BrB,mBAAmBpB,YAAYwC,sBACzB,oCAAegB,aAAchB,gBAAgB,IAErD,MAAO1D,aAEDwE,cAAgB3D,SAASC,cAAc,OAC7C0D,cAAczD,UAAY,mBAC1BuB,mBAAmBpB,YAAYsD,qBACzBC,eAAiB,mBACrB,wBACA,yBAEIrD,WAAWoD,wBAAkBC,sBAAazE,MAAM6C,SAAW,YAEjE0B,UAAUhC,UAAW"}